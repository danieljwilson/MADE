---
title: "prelim_data_clean_v4"
author: "Daniel J Wilson"
date: "11/16/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Clean up and Set WD

```{r clean}
# removes all variables but NOT functions
rm(list = setdiff(ls(), lsf.str()))

# SET WORKING DIRECTORY
setwd("~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/v4")
```

## Import CSV

```{r pressure, echo=FALSE}
setwd("~/Dropbox/PHD/CENDRI/Project/Code/LabSharedFolder/MADE01/CODE/v4_Episodic_Fractional/data/_full_data_files/")

#------------------------#
# IMPORT CSV FILES       #
#------------------------#
subjects = list.files(pattern="*.csv")
for (i in 1:length(subjects)){
  assign(paste0("s", i), read.csv(subjects[i]))
} 

#-------------------------#
# LOAD LIBRARIES          #
#-------------------------#
library(dplyr)
library(tidyverse)
library(plyr)

#-------------------------#
# INITIALIZE DATA FRAMES  #
#-------------------------#

full_v4_learning <- NULL
full_v4_trials <- NULL
# create testing df too?

#-------------------------#
#   FORMAT DATA FRAMES 
#   (break into Multiplier and non-Multiplier)
#-------------------------#

#loop through and create data frames
for (i in 1:length(subjects)) {
  
  temp <- eval(as.name(paste0("s", i)))
  
  #create learning and trials data frame
  temp_learning <- temp[!(is.na(temp$min_correct)), ]
  temp_trials <- temp[!(is.na(temp$numberEntry_4.keys) | temp$numberEntry_4.keys==""), ]
  
  #--------------------#
  # LEARNING           #
  #--------------------#
  #remove extraneous columns
  temp_learning <- temp_learning[, -c(1:40)]
  temp_learning <- temp_learning[, -c(15)]
  temp_learning <- temp_learning[, -c(18:19)]
  temp_learning <- temp_learning[, -c(22:39)]
  temp_learning <- temp_learning[, -c(23)]
  
  # convert to numeric
  temp_learning$key_resp_3.rt <- as.numeric(gsub('\\[|\\]', '', as.character(temp_learning$key_resp_3.rt)))
  temp_learning$key_resp_4.rt <- as.numeric(gsub('\\[|\\]', '', as.character(temp_learning$key_resp_4.rt)))
  
  # make
  #   stimuli_type (face/house)
  temp_learning$stimuli_type <- 'face'
  temp_learning$stimuli_type[min(which(!(is.na(temp_learning$key_resp_4.rt)))):nrow(temp_learning)] = 'house'
  #   trial_type (binary/exact)
  temp_learning$trial_type <- 'binary'
  temp_learning$trial_type[is.na(temp_learning$selected_image)] = 'exact'
  
  # RT & Choice for binary trials
  for(i in 1:nrow(temp_learning)){
    if(is.na(temp_learning$key_resp_3.rt[i]) && !(is.na(temp_learning$selected_image[i]))){
      temp_learning$key_resp_3.keys[i] = temp_learning$key_resp_4.keys[i]   # house trial binary choice
      temp_learning$key_resp_3.rt[i] = temp_learning$key_resp_4.rt[i]       # house trial rt
    }
  }
  
  # RT for exact trials (face)
  for(i in 1:nrow(temp_learning)){
    if(temp_learning$trial_type[i]=='exact' && temp_learning$stimuli_type[i]=='face'){
      test = strsplit(as.character(temp_learning$exitKeys_9.rt[i]), ", ")[[1]]
      test<- gsub('\\[|\\]', '', test)
      test <- list(as.numeric(test))
      temp_learning$key_resp_3.rt[i] <- tail(test[[1]], n=1)
    }
  }

  # RT for exact trials (house)
  for(i in 1:nrow(temp_learning)){
    if(temp_learning$trial_type[i]=='exact' && temp_learning$stimuli_type[i]=='house'){
      test = strsplit(as.character(temp_learning$exitKeys_11.rt[i]), ", ")[[1]]
      test<- gsub('\\[|\\]', '', test)
      test <- list(as.numeric(test))
      temp_learning$key_resp_3.rt[i] <- tail(test[[1]], n=1)
      # also move actual and guessed values
      temp_learning$actFaceVal[i] <- temp_learning$actHouseVal[i]
      temp_learning$guessFaceVal[i] <- temp_learning$guessHouseVal[i]
    }
  }
  
  temp_learning <- temp_learning[, -c(15:21)]
   #renameSomeColumns

  temp_learning <- plyr::rename(temp_learning, c("guessFaceVal"="guess_val", "actFaceVal"="act_val",
                                           "key_resp_3.keys"="binary_choice", "key_resp_3.rt"="rt"))

  #--------------------#
  # TRIALS             #
  #--------------------#
  #remove extraneous columns
  temp_trials <- temp_trials[, -c(1:45)]
  temp_trials <- temp_trials[, -c(2:5)]
  temp_trials <- temp_trials[, -c(3:18)]
  temp_trials <- temp_trials[, -c(10:11)]
  temp_trials <- temp_trials[, -c(12:15)]
  temp_trials <- temp_trials[, -c(13)]
  
  #--------------------#
  # COMBINE            #
  #--------------------#

  # #get original subject number
  # hold <- eval(as.name(paste0("s", i)))
  # temp_M$origNumber <- hold$participant[1:300]
  # 
  full_v4_learning <- rbind(full_v4_learning, temp_learning)
  full_v4_trials <- rbind(full_v4_trials, temp_trials)
}

```
### Import and Add Psydat Data

```{r import-psydat Echo=FALSE}
# data from psydat files
add_on = read_csv('~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/Data/v4_extra.csv')

# remove columns to match psydat file: 
  # first_image, last_image, num_fixations, rt
add_on$X1 = NULL
add_on$last_image = NULL
add_on$first_image = NULL
add_on$rt = NULL
add_on$num_fixations = NULL
add_on$round_num = NULL

# rename columns to match
full_v4_trials <- plyr::rename(full_v4_trials, c("Trial"="trial", "houseVal"="house_val", "faceVal"="face_val",
                                                 "imageList"="image_list", "numberEntry_4.keys" = "key_entry_list",
                                                 "numberEntry_4.rt" = "rt_list", "mult1House" = "house_mult",
                                                 "mult2Face" = "face_mult", "summedVal" = "summed_val"))

# concat the two dataframes
df_combine <- rbind(full_v4_trials, add_on)
```

## Add Columns to Trials

``` {r data-manipulation, echo=FALSE}

#--------------------#
# COMBINE            #
#--------------------#

# REINDEX
df_combine$timings = NULL
df_combine$rt = 1
df_combine$rt <- as.numeric(df_combine$rt)
# convert timings as factor to timings2 as list
for(x in 1:nrow(df_combine)){
  test <- strsplit(as.character(df_combine$rt_list[x]), ", ")[[1]]
  test<- gsub('\\[|\\]', '', test)
  df_combine$timings[x] <- list(as.numeric(test))
}

# add rt
for(x in 1:nrow(df_combine)){
  df_combine$rt[x] <- tail(df_combine$timings[x][[1]], n=1) # use last value in list to get RT value
}

# convert imageList as factor to imageSequence as list
for(x in 1:nrow(df_combine)){
  test <- strsplit(as.character(df_combine$image_list[x]), ", ")[[1]]
  test<- gsub('\\[|\\]', '', test)
  df_combine$image_sequence[x] <- list(as.numeric(test))
}

# convert key_entry_list as factor to acceptReject as list and add column
for(x in 1:nrow(df_combine)){
  test <- strsplit(as.character(df_combine$key_entry_list[x]), ", ")[[1]]
  test<- gsub('\\[|\\]', '', test)
  test<- gsub('space', '', test)
  df_combine$accept_reject[x] <- list(test)
  choice <- tail(df_combine$accept_reject[x][[1]], n=1)
  # f means accept
  if(choice == "'f'"){
    df_combine$accept_reject[x]=1
  }
  # j means reject
  if(choice == "'j'"){
    df_combine$accept_reject[x]=0
  }
}

#column for individual FIXATION TIMINGS
df_combine$fixation_timing <- vector("list", 20)

for(x in 1:nrow(df_combine)){
  for(y in 1:lengths(df_combine$timings[x])){
    if (y==1){
      subVal <- df_combine$timings[x][[1]][1]
      df_combine$fixation_timing[x][[1]][y] <- subVal
    }
    if (y>1){
      subVal <- df_combine$timings[x][[1]][y] - df_combine$timings[x][[1]][y-1]
      df_combine$fixation_timing[x][[1]][y] <- subVal
    }
  }
}

#FACE & HOUSE viewing time totals columns
#initialize columns
df_combine$total_fix_face_0 <- 0
df_combine$total_fix_house_1 <- 0
df_combine$first_image <- 0
df_combine$last_image <- 0

for(x in 1:nrow(df_combine)){
  #Column for last image looked at
  df_combine$first_image[x] <- tail(df_combine$image_sequence[x][[1]], n=1)
  df_combine$last_image[x] <- head(df_combine$image_sequence[x][[1]], n=1)
  
  for(y in 1:lengths(df_combine$fixation_timing[x])){ #length of imageSequence is the same
    #if the first image is 0
    if (df_combine$image_sequence[x][[1]][1]==0){ 
      if (y%%2 == 1){
        #add the even images for total 0
        df_combine$total_fix_face_0[x] <- df_combine$total_fix_face_0[x] + df_combine$fixation_timing[x][[1]][y] 
      }
      if (y%%2 == 0){
        #add the odd images for total 1
        df_combine$total_fix_house_1[x] <- df_combine$total_fix_house_1[x] + df_combine$fixation_timing[x][[1]][y] 
      }
    }
    #if the first image is 1
    if (df_combine$image_sequence[x][[1]][1]==1){ #if the first image is 0
      if (y%%2 == 1){
        #add the even images for total 0
        df_combine$total_fix_house_1[x] <- df_combine$total_fix_house_1[x] + df_combine$fixation_timing[x][[1]][y] 
      }
      if (y%%2 == 0){
        #add the odd images for total 1
        df_combine$total_fix_face_0[x] <- df_combine$total_fix_face_0[x] + df_combine$fixation_timing[x][[1]][y] 
      }
    }
  }
}

#Make row numbering sequential
rownames(df_combine) <- 1:nrow(df_combine)

#FINAL EARNINGS column
for (i in 1:length(unique(df_combine$participant))){
  start_val = (1 + (300 * (i-1)))
  stop_val = i*300
  df_combine$final_earnings[start_val:stop_val] = df_combine$earnings[stop_val]
}

#ABSOLUTE DIFFERENCE between the two values column
df_combine$abs_diff <-abs(df_combine$face_val - df_combine$house_val)

#new column with NUMBER OF SWAPS
df_combine$fix_num <- lengths(df_combine$image_sequence)

# create column w/ total value of face and house stimuli
df_combine$face_val_total = df_combine$face_val * df_combine$face_mult
df_combine$house_val_total = df_combine$house_val * df_combine$house_mult

#create first_val column [face is 0, house is 1]
for(x in 1:nrow(df_combine)){
  if (df_combine$first_image[x] == 0){
    df_combine$first_val[x] <- df_combine$face_val_total[x]
  }
  if (df_combine$first_image[x] == 1){
    df_combine$first_val[x] <- df_combine$house_val_total[x]
  }
}

#create second_val column [face is 0, house is 1 BUT since it is the second image it is the opposite]
for(x in 1:nrow(df_combine)){
  if (df_combine$first_image[x] == 1){
    df_combine$second_val[x] <- df_combine$face_val_total[x]
  }
  if (df_combine$first_image[x] == 0){
    df_combine$second_val[x] <- df_combine$house_val_total[x]
  }
}

#create firstMult column [face is 0, house is 1]
for(x in 1:nrow(df_combine)){
  if (df_combine$first_image[x] == 0){
    df_combine$first_mult[x] <- df_combine$face_mult[x]
  }
  if (df_combine$first_image[x] == 1){
    df_combine$first_mult[x] <- df_combine$house_mult[x]
  }
}

#create secondMult column (reverse the house/face values)
for(x in 1:nrow(df_combine)){
  if (df_combine$first_image[x] == 1){
    df_combine$second_mult[x] <- df_combine$face_mult[x]
  }
  if (df_combine$first_image[x] == 0){
    df_combine$second_mult[x] <- df_combine$house_mult[x]
  }
}

# Fixation Timings
for(i in 1:15){
  for(x in 1:nrow(df_combine)){
    df_combine[[paste0(i, "_fixation")]][x] <- df_combine$fixation_timing[x][[1]][i]
  }
}

```


## Clean Data

```{r clean Echo = FALSE}

outliersMAD <- function(data, MADCutOff = 2.5, replace = NA, values = FALSE, bConstant = 1.4826, digits = 2) {
  #compute number of absolute MADs away for each value
  #formula: abs( ( x - median(x) ) )/ mad(x)
  absMADAway <- abs((data - median(data, na.rm = T))/mad(data, constant = bConstant, na.rm = T))
  #subset data that has absMADAway greater than the MADCutOff and replace them with replace
  #can also replace values other than replace
  data[absMADAway > MADCutOff] <- replace
  
  if (values == TRUE) { 
    return(round(absMADAway, digits)) #if values == TRUE, return number of mads for each value
  } else {
    return(round(data, digits)) #otherwise, return values with outliers replaced
  }
}

df_combine <- df_combine[!(outliersMAD(df_combine$rt, values=T) > 5),]
clean_v4_learning <- full_v4_learning[!(outliersMAD(full_v4_learning$rt, values=T) > 5),]
max(df_combine$rt)

length(df_combine$trial)

#SAVE Rdata FILE
#v4_learning <- clean_v4_learning
#save(v3_learning, file = "~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/Data/v3_learning.Rdata")

v4_trials <- df_combine
save(v4_trials, file = "~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/Data/v4_trials.Rdata")
```

```{r load-data Echo=FALSE}
load("~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/Data/v4_trials.Rdata")
#load("~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis/Data/v4_learning.Rdata")
```

### Plot unfiltered data

```{r RT_Earnings-unfiltered, echo=FALSE}

load("../Data/v4_trials.Rdata")

#################
# FUNCTION TO PULL DATA OUT OF LM
#################

ggplotRegression <- function (fit) {
  require(ggplot2)
  ggplot(fit$model, aes_string(x=names(fit$model)[2], y=names(fit$model)[1])) +
    geom_point() +
    stat_smooth(method = "lm", col = "red") +
    ggtitle("Testing") +
    labs(title = paste(title, "\n\nAdj R2 = ",signif(summary(fit)$adj.r.squared, 5),
                       "Intercept =",signif(fit$coef[[1]], 5),
                       "Slope =",signif(fit$coef[[2]], 5),
                       "P =",signif(summary(fit)$coef[2,4], 5)))
}

#################
# INITIAL PLOTS
#################

#Select dataframe to use
d <- v4_trials
d$correct = as.numeric(d$correct) - 1 #make accuracy numeric

#mean RT and Final earnings by subject
subject_means <- group_by(d, participant) %>%
  dplyr::summarize(rt = mean(rt, na.rm = T), final_earnings = mean(final_earnings, na.rm = T))

title = "Earnings as related to Mean RT"
ggplotRegression(lm(final_earnings~rt, data = subject_means))

#mean RT and Accuracy by subject
subject_means <- group_by(d, participant) %>%
  dplyr::summarize(final_earnings = mean(final_earnings, na.rm = T), accuracy = mean(as.numeric(correct), na.rm = T))

title = "Earnings as related to % Correct"
ggplotRegression(lm(final_earnings~accuracy, data = subject_means))

#mean RT and Final earnings by subject
subject_means2 <- group_by(d, participant) %>%
  dplyr::summarize(fix_num = mean(fix_num, na.rm = T), final_earnings = mean(final_earnings, na.rm = T))

title = "Earnings as related to Number of Image Swaps"
ggplotRegression(lm(final_earnings~fix_num, data = subject_means2))
```

## REMOVE BAD SUBJECTS
```{r remove-bad-subjects Echo=FALSE}
length(unique(v4_trials$participant))

d <- v4_trials

# create mean fix column to use to remove subjects
subject_means <- group_by(d, participant) %>%
  dplyr::summarize(mean_fix = mean(fix_num, na.rm = T))

for (i in unique(v4_trials$participant)){
  v4_trials$mean_fix[v4_trials$participant == i] = subject_means$mean_fix[subject_means$participant == i]
}

#remove flip avgs less than 1.5
v2_trials_clean <- v4_trials[!(v4_trials$mean_fix<1.5),]
length(unique(v2_trials_clean$participant))

# add Column for Choice
v2_trials_clean$choice = as.numeric(v2_trials_clean$accept_reject)
v2_trials_clean$summedVal = v2_trials_clean$summed_val
v2_trials_clean$subject = v2_trials_clean$participant
v2_trials_clean$absSummedVal = abs(v2_trials_clean$summed_val)
v2_trials_clean$swapAmount = v2_trials_clean$fix_num
v2_trials_clean$firstMult = v2_trials_clean$first_mult
v2_trials_clean$firstVal = v2_trials_clean$first_val
v2_trials_clean$secondMult = v2_trials_clean$second_mult
v2_trials_clean$secondVal = v2_trials_clean$second_val
v2_trials_clean$faceTotal = v2_trials_clean$face_val_total
v2_trials_clean$houseTotal = v2_trials_clean$house_val_total
v2_trials_clean$total_0_face = v2_trials_clean$total_fix_face_0
v2_trials_clean$total_1_house = v2_trials_clean$total_fix_house_1

v2_clean <- v2_trials_clean

# Save for R
save(v2_clean, file = "../Data/v2_clean.Rdata")

# save for HDDM
v2_hddm<-v2_trials_clean
# delete lists
v2_hddm$timings = NULL
v2_hddm$image_sequence = NULL
v2_hddm$choice = as.numeric(v2_hddm$accept_reject) 
v2_hddm$accept_reject = NULL
v2_hddm$fixation_timing = NULL

write.csv(v2_hddm, file = "../hDDM/Data/CSV_data/v2_clean.csv") 
```


## RT DISTRIBUTION
```{r init-data-exploration Echo=FALSE}

df = v4_trials_clean

#find subject accruacy (uncleaned)
accuracy = tapply(df$correct==1, df$participant, mean)

#hists of rt based on congruent and incongruent trials
hist(df[df$correct==1, ]$rt,
   col=rgb(1,0,0,0.5), breaks=seq(0,15,0.1), ylim=c(0,225), xlab="RT", main = "RT vs Frequency")
abline(v=median(df[df$correct==1, ]$rt), col="red")
hist(df[df$correct==0, ]$rt,
   col=rgb(0,0,1,0.5), breaks=seq(0,15,0.1), ylim=c(0,225), add=T)
abline(v=median(df[df$correct==0, ]$rt), col="blue")

legend("bottomright", c("Correct", "Incorrect"), fill=c(rgb(1,0,0,0.5), rgb(0,0,1,0.5)))
legend("topright",
       c(as.expression(bquote(Correct_Median == .(median(df[df$correct==1, ]$rt)))), as.expression(bquote(Incorrect_Median == .(median(df[df$correct==0, ]$rt))))),
       col = c("red", "blue"),
       lwd = c(2, 2, 1))

x = df$rt[df$correct==1]
y = df$rt[df$correct==0]
t.test(x,y)
```

```{r plot-1 Echo=FALSE}
df = v4_trials_clean
#RT vs. Summed Value
ggplot(df, aes(x=summed_val, y=rt)) +
  geom_point(shape=1) +    # Use hollow circles
  geom_smooth()  # Add a loess smoothed fit curve with confidence region
```


## BASIC PSYCHOMETRIC comparison

```{r}
# Figure out histogram bin size, based on equal numbers of observations
library(Hmisc) # cut2

d <- v4_trials_clean
d$choice = as.numeric(d$accept_reject)

# How many bins?
numBins = 19 # same as Krajbich

# SUMMED VAL
d$valBin <- as.numeric(cut2(d$summed_val, g=numBins))
d$valBinAmt <- cut2(d$summed_val, g=numBins)
d$valBinCtr <- cut2(d$summed_val, g=numBins, levels.mean=TRUE)
vals = as.numeric(as.character(unique(d$valBinCtr)))
vals = sort(vals)

# FOR RT
subject_means_rt <- group_by(d, participant, valBinCtr) %>%
  dplyr::summarize(rt = mean(rt, na.rm = T))
subject_means_rt

# FOR ACCURACY
subject_means_acc <- group_by(d, participant, valBinCtr) %>%
  dplyr::summarize(correct = mean(correct, na.rm = T))
subject_means_acc

# FOR CHOICE
subject_means_choice <- group_by(d, participant, valBinCtr) %>%
  dplyr::summarize(accept = mean(choice, na.rm = T))
subject_means_choice

# Create DF with all bins as columns
# FOR RT
subject_means_wide_rt <-
  spread(subject_means_rt,
         key = valBinCtr,
         value = rt,
         sep = "_")

# FOR ACCURACY
subject_means_wide_acc <-
  spread(subject_means_acc,
         key = valBinCtr,
         value = correct,
         sep = "_")

# FOR CHOICE
subject_means_wide_choice <-
  spread(subject_means_choice,
         key = valBinCtr,
         value = accept,
         sep = "_")

# DF with mean and SD for each bin

rt_x = sapply(subject_means_wide_rt, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
rt_x = t(rt_x)
acc_x = sapply(subject_means_wide_acc, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
acc_x = t(acc_x)
choice_x = sapply(subject_means_wide_choice, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
choice_x = t(choice_x)

# MEANs
rt_mean = numeric()
acc_mean = numeric()
choice_mean = numeric()
for(i in 2:19){
  rt_mean = c(rt_mean, rt_x[i,1][[1]])
  acc_mean = c(acc_mean, acc_x[i,1][[1]])
  choice_mean = c(choice_mean, choice_x[i,1][[1]])
}

# SDs
rt_sd = numeric()
acc_sd = numeric()
choice_sd = numeric()
for(i in 2:19){
  rt_sd = c(rt_sd, rt_x[i,2][[1]])
  acc_sd = c(acc_sd, acc_x[i,2][[1]])
  choice_sd = c(choice_sd, choice_x[i,2][[1]])
}

# Create DF
df = data.frame("val" = vals,
                "rt_mean" = rt_mean, "rt_sd" = rt_sd,
                "acc_mean" = acc_mean, "acc_sd" = acc_sd,
                "choice_mean" = choice_mean, "choice_sd" = choice_sd)

# Add SEs
nVal = sqrt(length(unique(d$participant))) # calculate the denominator of the SE equation
df$rt_se <- df$rt_sd/nVal
df$acc_se <- df$acc_sd/nVal
df$choice_se <- df$choice_sd/nVal

#-----------#
# PLOT      # 
#-----------#

# RT
ggplot(data = df,aes(x = val,y = rt_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = rt_mean-rt_se,ymax = rt_mean+rt_se)) + 
  labs(x = "Net Value", y = "Reaction Time (seconds)") +
  theme_minimal() +
  ggtitle("Mean Reaction Time by Net Value")
  
# ACCURACY
ggplot(data = df,aes(x = val,y = acc_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = acc_mean-acc_se, ymax = acc_mean+acc_se)) + 
  labs(x = "Net Value", y = "p(Correct)") +
  theme_minimal() +
  ggtitle("B") +
  theme(plot.title = element_text(size=22))
#  ggtitle("p(Correct) by Net Value ")

# CHOICE
ggplot(data = df,aes(x = val,y = choice_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = choice_mean-choice_se, ymax = choice_mean+choice_se)) + 
  labs(x = "Net Value", y = "p(Accept)") +
  scale_x_continuous(breaks = seq(-3,3,0.5)) +
  theme_minimal() +
  theme(axis.title.x=element_text(size=17),
        axis.title.y = element_text(size = 17))
  #ggtitle("A") +
  #theme(plot.title = element_text(size=22))

setwd("/Users/djw/Dropbox/PHD/PRESENTATIONS/2017_SNE/Plots")
ggsave("Prob.png", width = 19, height = 12, units = "cm")

#T-TEST for trials
#t.test(subject_means_wide$flip_1, subject_means_wide$flip_2, paired = TRUE)
```

## PSCYHOMETRICS continued (abs val for rt and fix)

```{r}
# ABS Val
d <- v4_trials_clean

d$absValBin <- as.numeric(cut2(abs(d$summed_val), g=9))
d$absValBinAmt <- cut2(abs(d$summed_val), g=9)
d$absValBinCtr <- cut2(abs(d$summed_val), g=9, levels.mean=TRUE)
absVals = as.numeric(as.character(unique(d$absValBinCtr)))
absVals = sort(absVals)

# Abs Val RT
abs_subject_means_rt <- group_by(d, participant, absValBinCtr) %>%
  dplyr::summarize(rt = mean(rt, na.rm = T))
abs_subject_means_rt

# FOR Fixations
abs_subject_means_fix <- group_by(d, participant, absValBinCtr) %>%
  dplyr::summarize(fixations = mean(fix_num, na.rm = T))
abs_subject_means_fix

# Create DF with all bins as columns
# FOR RT
abs_subject_means_wide_rt <-
  spread(abs_subject_means_rt,
         key = absValBinCtr,
         value = rt,
         sep = "_")

# FOR ACCURACY
abs_subject_means_wide_fix <-
  spread(abs_subject_means_fix,
         key = absValBinCtr,
         value = fixations,
         sep = "_")

# DF with mean and SD for each bin

rt_x = sapply(abs_subject_means_wide_rt, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
rt_x = t(rt_x)
fix_x = sapply(abs_subject_means_wide_fix, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
fix_x = t(fix_x)

rt_x

rt_mean = numeric()
fix_mean = numeric()
for(i in 2:9){
  rt_mean = c(rt_mean, rt_x[i,1][[1]])
  fix_mean = c(fix_mean, fix_x[i,1][[1]])
}

rt_sd = numeric()
fix_sd = numeric()
for(i in 2:9){
  rt_sd = c(rt_sd, rt_x[i,2][[1]])
  fix_sd = c(fix_sd, fix_x[i,2][[1]])
}


df = data.frame("abs_val" = absVals, "rt_mean" = rt_mean, "rt_sd" = rt_sd, "fix_mean" = fix_mean, "fix_sd" = fix_sd)
nVal = sqrt(length(unique(d$participant))) # calculate the denominator of the SE equation
df$rt_se <- df$rt_sd/nVal
df$fix_se <- df$fix_sd/nVal
df

#-----------#
# PLOT      # 
#-----------#

# RT
ggplot(data = df,aes(x = abs_val,y = rt_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = rt_mean-rt_se,ymax = rt_mean+rt_se)) + 
  labs(x = "Absolute Net Value ($)", y = "Reaction Time (s)") +
  scale_x_continuous(breaks = seq(0,3,0.5)) +
  scale_y_continuous(breaks = seq(2.2,5.0,0.2)) +
  theme_minimal()+
  theme(axis.title.x=element_text(size=18),
        axis.title.y = element_text(size = 18))
  ggtitle("Mean Reaction Time by Absolute Net Value")
  
# FIXATIONS
ggplot(data = df,aes(x = abs_val,y = fix_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = fix_mean-fix_se, ymax = fix_mean+fix_se)) + 
  labs(x = "Absolute Net Value ($)", y = "Fixation Count") +
  scale_x_continuous(breaks = seq(0,3,0.5)) +
  scale_y_continuous(breaks = seq(2.4,4.0,0.1)) +
  theme_minimal()+
  theme(axis.title.x=element_text(size=17),
        axis.title.y = element_text(size = 17))
  ggtitle("Fixations by Absolute Net Value ")

# SAVE PLOTS  
#setwd("/Users/djw/Dropbox/PHD/PRESENTATIONS/2017_SNE/Plots")
#ggsave("RT.png", width = 19, height = 12, units = "cm")
  

```

## RT vs VALUE by paradigm
```{r}

# set WD
setwd("~/Dropbox/PROGRAMMING/_NEURO/2017_MADE/Analysis")
load("Data/S_M.Rdata")

#RT vs. Summed Value
ggplot() +
  geom_smooth(aes(x=summedVal, y=rt, group = factor(id), colour = factor(id)), df_mults) +
  #geom_smooth(aes(x=summedVal, y=correct, colour = "flip"), subset(total_M_clean3, flip==1)) +
  coord_cartesian(xlim = c(-3, 3))  +
  scale_x_continuous(name="Net Value ($)", seq(-3,3,0.5), limits = c(-3,3))+
  scale_y_continuous(name = "Reaction Time (s)") +
  scale_color_manual(labels = c("Secondary", "Primary"), values = c("blue", "red")) +
  guides(colour=guide_legend("Study")) +
  ggtitle("B") +
  theme_minimal()+
  theme(legend.position="none")

  #geom_point(shape=1) +    # Use hollow circles
  geom_smooth()  # Add a loess smoothed fit curve with confidence region
```

### P(accept) v NET VALUE
### RT v abs(NET VALUE)
### # of Swaps v abs(NET VALUE)




## FIRST FIXATION DWELL TIME by Mult and Net Value

```{r}
df = v4_trials_clean
df$first_val_base = df$first_val/df$first_mult
df$second_val_base = df$second_val/df$second_mult

# COLLAPSED OVER MULTS
# First fix dwell time
abs_subject_means_rt_1 <- group_by(df, participant, first_val_base) %>%
  dplyr::summarize(first_fix = mean(`1_fixation`, na.rm = T))

# Second fix dwell time
# New df - cut out trials where second fix is FINAL fix
df_second <- df[df$fix_num>2,]
abs_subject_means_rt_2 <- group_by(df, participant, second_val_base) %>%
  dplyr::summarize(second_fix = mean(`2_fixation`, na.rm = T))

# Create DF with all bins as columns
# FOR RT
abs_subject_means_wide_rt_1 <-
  spread(abs_subject_means_rt_1,
         key = first_val_base,
         value = first_fix,
         sep = "_")

abs_subject_means_wide_rt_2 <-
  spread(abs_subject_means_rt_2,
         key = second_val_base,
         value = second_fix,
         sep = "_")

# DF with mean and SD for each bin

first = sapply(abs_subject_means_wide_rt_1, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
first = t(first)
second = sapply(abs_subject_means_wide_rt_2, function(cl) list(means=mean(cl,na.rm=TRUE), sds=sd(cl,na.rm=TRUE)))
second = t(second)

first_mean = numeric()
for(i in 2:10){
  first_mean = c(first_mean, first[i,1][[1]])
}
second_mean = numeric()
for(i in 2:10){
  second_mean = c(second_mean, second[i,1][[1]])
}

first_sd = numeric()
for(i in 2:10){
  first_sd = c(first_sd, first[i,2][[1]])
}
second_sd = numeric()
for(i in 2:10){
  second_sd = c(second_sd, second[i,2][[1]])
}

fix_vals = sort(unique(df$first_val_base))

df = data.frame("values" = first_fix_vals, "first_mean" = first_mean, "first_sd" = first_sd,
                "second_mean" = second_mean, "second_sd" = second_sd)
nVal = sqrt(length(unique(d$participant))) # calculate the denominator of the SE equation
df$first_se <- df$first_sd/nVal
df$second_se <- df$second_sd/nVal
df

#-----------#
# PLOT      # 
#-----------#

# RT FIRST FIX
ggplot(data = df,aes(x = values,y = first_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = first_mean-first_se,ymax = first_mean+first_se)) + 
  labs(x = "Base Value ($)", y = "Fixation Time (s)") +
  scale_x_continuous(breaks = seq(-3,3,0.25)) +
  scale_y_continuous(breaks = seq(1.0,2.2,0.05)) +
  theme_minimal()+
  theme(axis.title.x=element_text(size=18),
        axis.title.y = element_text(size = 18)) + 
  ggtitle("First Fixation: Collapsed Across Mults")

# RT SECOND FIX
ggplot(data = df,aes(x = values,y = second_mean)) + 
  geom_point() + 
  #geom_line() +
  geom_errorbar(aes(ymin = second_mean-second_se,ymax = second_mean+second_se)) + 
  labs(x = "Base Value ($)", y = "Fixation Time (s)") +
  scale_x_continuous(breaks = seq(-3,3,0.25)) +
  scale_y_continuous(breaks = seq(1.0,2.2,0.05)) +
  theme_minimal()+
  theme(axis.title.x=element_text(size=18),
        axis.title.y = element_text(size = 18)) + 
  ggtitle("Second Fixation: Collapsed Across Mults")
```

## Separated By Multiplier
```{r}
# SEPARATED BY MULT
df = v4_trials_clean
df$first_val_base = df$first_val/df$first_mult

# First fix
first <- ggplot(df, aes(x = first_val_base, y = `1_fixation`, colour = factor(first_mult))) +
  stat_summary(fun.y = "mean", geom = "line") +
  
  guides(colour=guide_legend("Multiplier \nCondition")) +
  scale_x_continuous(name="Attribute Base Value ($)")+
  scale_y_continuous(name = "Attribute Dwell Time (s)")+
  ggtitle("First Fixation: Separated by Multiplier")
first

# Second fix
df$second_val_base = df$second_val/df$second_mult
df_second <- df[df$fix_num>2,]

second <- ggplot(df_second, aes(x = second_val_base, y = `2_fixation`, colour = factor(first_mult))) +
  stat_summary(fun.y = "mean", geom = "line") +
  
  guides(colour=guide_legend("Multiplier \nCondition")) +
  scale_x_continuous(name="Attribute Base Value ($)")+
  scale_y_continuous(name = "Attribute Dwell Time (s)")+
  ggtitle("Second Fixation: Separated by Multiplier")
second


#-----------#
# PLOT      # 
#-----------#
# 
# # RT FIRST FIX
# ggplot(data = df,aes(x = values,y = first_mean)) + 
#   geom_point() + 
#   #geom_line() +
#   geom_errorbar(aes(ymin = first_mean-first_se,ymax = first_mean+first_se)) + 
#   labs(x = "Base Value ($)", y = "Fixation Time (s)") +
#   scale_x_continuous(breaks = seq(-3,3,0.25)) +
#   scale_y_continuous(breaks = seq(1.0,2.2,0.05)) +
#   theme_minimal()+
#   theme(axis.title.x=element_text(size=18),
#         axis.title.y = element_text(size = 18)) + 
#   ggtitle("First Fixation: Collapsed Across Mults")
# 
# # RT SECOND FIX
# ggplot(data = df,aes(x = values,y = second_mean)) + 
#   geom_point() + 
#   #geom_line() +
#   geom_errorbar(aes(ymin = second_mean-second_se,ymax = second_mean+second_se)) + 
#   labs(x = "Base Value ($)", y = "Fixation Time (s)") +
#   scale_x_continuous(breaks = seq(-3,3,0.25)) +
#   scale_y_continuous(breaks = seq(1.0,2.2,0.05)) +
#   theme_minimal()+
#   theme(axis.title.x=element_text(size=18),
#         axis.title.y = element_text(size = 18)) + 
#   ggtitle("Second Fixation: Collapsed Across Mults")
  
#RT vs. Summed Value First Fixation
ggplot() +
  geom_smooth(aes(x=jitter(first_val_base), y=`1_fixation`, group = factor(first_mult), colour = factor(first_mult)), n=17, df) +
  #geom_smooth(aes(x=summedVal, y=logRT, colour = "flip"), subset(total_M_clean3, flip==1)) +
  coord_cartesian(xlim = c(-1.1, 1.1))  +
  #ggtitle("First Fixation Timing vs Total Value")
  #geom_point(shape=1) +    # Use hollow circles
  geom_smooth(n = 17) +  # Add a loess smoothed fit curve with confidence region
  theme_minimal()+
  guides(colour=guide_legend("Multiplier \nCondition")) +
  scale_x_continuous(name="Attribute Weighted Value ($)", seq(-3,3,0.5), limits = c(-3,3))+
  scale_y_continuous(name = "Attribute Dwell Time (s)")+
  theme(axis.title.x=element_text(size=14),
        axis.title.y = element_text(size = 14))
#  theme(legend.position="none")

#RT vs. Summed Value First Fixation
ggplot() +
  geom_smooth(aes(x=jitter(second_val_base), y=`2_fixation`, group = factor(second_mult), colour = factor(second_mult)), n=17, df_second) +
  #geom_smooth(aes(x=summedVal, y=logRT, colour = "flip"), subset(total_M_clean3, flip==1)) +
  coord_cartesian(xlim = c(-1.1, 1.1))  +
  #ggtitle("First Fixation Timing vs Total Value")
  #geom_point(shape=1) +    # Use hollow circles
  geom_smooth(n = 17) +  # Add a loess smoothed fit curve with confidence region
  theme_minimal()+
  guides(colour=guide_legend("Multiplier \nCondition")) +
  scale_x_continuous(name="Attribute Weighted Value ($)", seq(-3,3,0.5), limits = c(-3,3))+
  scale_y_continuous(name = "Attribute Dwell Time (s)")+
  theme(axis.title.x=element_text(size=14),
        axis.title.y = element_text(size = 14))
  #theme(legend.position="none")
```

# MODELS

```{r}
library(lme4)
library(nlme)
library(effects)
library(car)


# Reload Data
d <- v4_trials_clean
d$participant <- factor(d$participant)
d$choice <- as.numeric(d$accept_reject)
# Bias to weigh the face value more than justified?
fit <- glmer(choice ~ face_val_total * total_fix_face_0 + house_val_total * total_fix_house_1 + (1 + face_val_total * total_fix_face_0 + house_val_total * total_fix_house_1 | participant), family = binomial("logit"), data = d)
summary(fit)

# turn into dataframe
fitDf <- as.data.frame.matrix(coef(summary(fit))) 
names(fitDf)[names(fitDf) == "Std. Error"] <- 'se'
names(fitDf)[names(fitDf) == "z value"] <- 'z'
names(fitDf)[names(fitDf) == "Pr(>|z|)"] <- 'p'
fitDf$'Fixed Effects'<-rownames(fitDf)

# remove intercept
fitDf = fitDf[-1,]
fitDf[1,5] = "WFV"
fitDf[2,5] = "TFD"
fitDf[3,5] = "WHV"
fitDf[4,5] = "THD"
fitDf[5,5] = "WFV:TFD"
fitDf[6,5] = "WHV:THD"

# *'s for significance
fitDf$star <- ""
fitDf$star[fitDf$p <= .05]  <- "*"
fitDf$star[fitDf$p <= .01]  <- "**"
fitDf$star[fitDf$p <= .001] <- "***"

# Bar Plot
positions <- c("WFV", "WHV", "TFD", "THD", "WFV:TFD", "WHV:THD")

ggplot(fitDf, aes(`Fixed Effects`, z, fill=`Fixed Effects`)) + 
  geom_bar(stat = "identity", width = 0.5) + 
  geom_errorbar(aes(ymin=z-se, ymax=z+se), width=0.4) +
  geom_text(aes(label=star), colour="black", vjust=0, size=6) +
  scale_x_discrete(limits = positions) +
  theme_minimal() +
  theme(axis.title.x=element_text(size=14),
      axis.title.y = element_text(size = 14))+
  theme(legend.position="none")


```

## FIXATION DURATION
### First Fixation (by multiplier and underlying value)
### Second Fixation (by multiplier and underlying value)
### Middle Fixations (by multiplier and underlying value)

## BIAS
### Choice biased by fixation time?
### Choice biased by last fixation?

## ACCURACY
### Accuracy v. Net Value (by multiplier)
### Accuracy v. Base Value (by multiplier)

## LEARNING EFFECTS ON PERFORMANCE
### FASTER LEARNERS: Accuracy? Speed? Swaps?

